http://www.1point3acres.com/bbs/forum.php?mod=viewthread&tid=208044&extra=page%3D1%26filter%3Dsortid%26sortid%3D311%26searchoption%5B3090%5D%5Bvalue%5D%3D2%26searchoption%5B3090%5D%5Btype%5D%3Dradio%26searchoption%5B3046%5D%5Bvalue%5D%3D2%26searchoption%5B3046%5D%5Btype%5D%3Dradio%26sortid%3D311

1. level order traversal，打印出每层最大的两个数字，如果不到2个，就打印null.

struct TreeNode {
  TreeNode* left;
  TreeNode* right;
  int val;
};
int levelprint(TreeNode* root) {
  // use bfs
  list<TreeNode*> lt0body, lt1body;
  list<TreeNode*> *lt0 = &lt0body;
  list<TreeNode*> *lt1 = &lt1body;
  
  lt0->push_back(root);
  int max0 = INT_MIN, max1 = INT_MIN;
  while (!lt0->empty()) {
    if (lt0->size() < 2) {
      cout << "NULL" << endl;
      for (auto tempnode : *lt0) {
        if (tempnode->left != nullptr) {
          lt1->push_back(tempnode->left);
        }
        if (tempnode->right != nullptr) {
          lt1->push_back(tempnode->right);
        }
      }
      lt0->clear();
      swap(lt0, lt1);
    }
    else {
      max0 = INT_MIN; 
      max1 = INT_MIN;
      for (auto tempnode : *lt0) {
        if (tempnode->val >= max0) {
          swap(max0, max1);
          max0 = tempnode->val;
        }
        else if (tempnode->val > max1) {
          max1 = tempnode->val;
        }
        if (tempnode->left != nullptr) {
          lt1->push_back(tempnode->left);
        }
        if (tempnode->right != nullptr) {
          lt1->push_back(tempnode->right);
        }
      }
      cout << max0 << " " << max1 << endl;
      lt0->clear();
      swap(lt0, lt1);
    }
  }
  return 0;
}

2. random return number according to weight
int randnum(vector<int>& nums, vector<int>& weights) {
  int size = nums.size();
  vector<int> presum(size, 0);
  presum[0] = weights[0];
  for (int i = 1; i < size; ++i) {
    presum[i] = presum[i-1] + weights[i];
  }
  // generate a number between [1, presum[size-1]], number locate in (presum[i-1], presum[i]] means nums[i], where 
  // we assume presum[-1] to be 0.
  srand(time(nullptr));
  int rnum = rand()%presum[size-1]+1;
  int ind = binarysearch(presum, rnum);
  return nums[ind];
}

int binarysearch(vector<int>& nums, int val) {
  int size = nums.size();
  int start = 0, end = size - 1;
  while (start <= end) {
    int median = (start + end)/2;
    if (nums[median] == val) {
      return media;
    }
    else if (nums[median] > val) {
      end = median - 1;
    }
    else {
      start = median + 1;
    }
  }
  return start;
}

10. Regular Expression Matching

'.' Matches any single character.
'*' Matches zero or more of the preceding element.

The matching should cover the entire input string (not partial).

The function prototype should be:
bool isMatch(const char *s, const char *p)

Some examples:
isMatch("aa","a") → false
isMatch("aa","aa") → true
isMatch("aaa","aa") → false
isMatch("aa", "a*") → true
isMatch("aa", ".*") → true
isMatch("ab", ".*") → true
isMatch("aab", "c*a*b") → true

// dynamic programming
// f[i][j] is 1 if s[0...i-1] matches p[0...j-1]
// f[0][0] is 1, since empty matches empty
// f[i][0] is 0, since p is empty for i >= 1
// f[0][1] is 0
// f[0][j] is 1 if f[0][j-2] is 1 and p[j-1] is '*' for j >= 2
// f[i][j] is 1 if p[j-1] not *, then f[i-1][j-1] == 1 and p[j-1] == '.' || p[j-1] == s[i-1]
//              if p[j-1]  is *, then f[i][j-2] == 1
//                                 or f[i-1][j] == 1 && p[j-2] == '.' || p[j-2] == s[i-1]
bool isMatch(string s, string p) {
  int ssize = s.size();
  int psize = p.size();
  
  vector<vector<int>> match(ssize+1, vector<int>(psize+1, 0));
  
  match[0][0] = 1;
  for (int j = 2; j <= psize; ++j) {
    if ((p[j-1] == '*') && (match[0][j-2] == 1)) {
      match[0][j] = 1;
    }
  }
  for (int i = 1; i <= ssize; ++i) {
    for (int j = 1; j <= psize; ++j) {
      if ((p[j-1] != '*') && (match[i-1][j-1] == 1) && (p[j-1] == '.' || p[j-1] == s[i-1])) {
        match[i][j] = 1;
      }
      if (
          (p[j-1] == '*') && 
          (
              (match[i][j-2] == 1) || 
              ((match[i-1][j] == 1) && (p[j-2] == '.' || p[j-2] == s[i-1]))
          )
         ){
        match[i][j] = 1;
      }
    }
  }
  
  return match[ssize][psize] == 1;
}

// Use recursive
// help(string& s, string& p, int si, int pi) returns true if s[0..si-1] and p[0..pi-1] match
bool help(string& s, string& p, int si, int pi) {
  if ((si == 0) && (pi == 0)) {
    return true;
  }
  
  if ((si == 0) && (pi >= 2)) {
    return help(s, p, si, pi-2) && (p[pi-1] == '*');
  }
  
  if ((si >=1) && (pi >=1)) {
    if (p[pi-1] != '*') {
      return help(s, p, si-1, pi-1) && (s[si-1] == p[pi-1] || p[pi-1] == '.');
    }
    else {
      return help(s, p, si, pi-2) || (help(s, p, si-1, pi) && ((s[si-1] == p[pi-2]) || (p[pi-2] == '.')));
    }
  }
  return false;
}

bool isMatch(string s, string p) {
  int ssize = s.size();
  int psize = p.size();
  return help(s, p, ssize, psize);
}
